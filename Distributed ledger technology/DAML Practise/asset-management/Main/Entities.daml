module Main.Entities where

import Main.Data
import Main.Fund
import Main.Token
import Main.Assets
import Main.Utils

import DA.Optional

template AssetManager
 with 
  assetManager: Party
  investors: [Party]
 where
  signatory assetManager

  key assetManager: Party
  maintainer key

  choice RegisterInvestor: (ContractId AssetManager, ContractId Investor)
   with investor: Party
   controller assetManager
   do 
    inv <- create Investor with assetManager; investor
    am <- create this with investors = investor :: investors
    return (am, inv)
 
  nonconsuming choice RegisterFund: ContractId Fund
   with fundDetails: FundDetails
   controller assetManager
   do create Fund with assetManager; fundDetails; investors
  
  nonconsuming choice CreateCash: ContractId Cash
   with amount: Decimal; currency: Text; investor: Party; timestamp: Int
   controller assetManager
   do
    let cashId = createUniqueIdentifier [(show investor), currency]
    existingCash <- lookupByKey @Cash (assetManager, cashId)
    case existingCash of
     None -> do create Cash with assetManager; investor; id = cashId; currency; amount; latestUpdateTimestamp = timestamp
     Some cashCid -> do
      cash <- fetch cashCid
      archive cashCid
      create cash with amount = cash.amount + amount; latestUpdateTimestamp = timestamp
  
  nonconsuming choice GenerateCoupon: [ContractId Cash]
   with fundId: Text; timestamp: Int
   controller assetManager
   do
    fundCid <- lookupByKey @Fund (assetManager, fundId)
    assertMsg "Fund not found" (isSome fundCid)
    fund <- fetch (fromSome fundCid)

    tokenOptionals <- mapA (\x -> lookupByKey @Token (assetManager, createUniqueIdentifier [(show x), fundId])) investors
    let tokenCids = catOptionals tokenOptionals
    tokens <- mapA fetch tokenCids
    mapA (\x -> do
           let cashId = createUniqueIdentifier [(show x.investor), fund.fundDetails.currency]
           cashCid <- lookupByKey @Cash (assetManager, cashId)
           let couponCash = intToDecimal(fund.fundDetails.subscriptionCost * x.tokens) * fund.fundDetails.interest
           case cashCid of
            None -> do create Cash with 
                        assetManager; investor = x.investor; id = cashId
                        amount = couponCash; currency = fund.fundDetails.currency; latestUpdateTimestamp = timestamp
            Some cashCid -> do
             cash <- fetch cashCid
             archive cashCid
             create cash with amount = cash.amount + couponCash; latestUpdateTimestamp = timestamp
         ) tokens

  nonconsuming choice Match: ()
   with buyer: Party; seller: Party; fundId: Text; timestamp: Int
   controller assetManager
   do
    sellOfferCid <- lookupByKey @SellOffer (assetManager, seller, fundId)
    assertMsg "SellOffer not found" (isSome sellOfferCid)
    buyOfferCid <- lookupByKey @BuyOffer (assetManager, buyer, fundId)
    assertMsg "BuyOffer not found" (isSome buyOfferCid)

    sellOffer <- fetch (fromSome sellOfferCid)
    buyOffer <- fetch (fromSome buyOfferCid)
    assertMsg "Cannot match, buyer and seller are the same" (buyOffer.buyer /= sellOffer.seller)
    assertMsg "Cannot match, buy price is lower than sell price" (buyOffer.pricePerToken >= sellOffer.pricePerToken)
    assertMsg "Cannot match, offers use different currencies" (buyOffer.currency == sellOffer.currency)

    let totalBuyPrice = buyOffer.pricePerToken * intToDecimal(buyOffer.buyAmount)
    transferTokens(assetManager, seller, buyer, fundId, buyOffer.buyAmount, timestamp)
    transferCash(assetManager, buyer, seller, totalBuyPrice, buyOffer.currency, timestamp)
    updateOffers((fromSome buyOfferCid), (fromSome sellOfferCid), buyOffer.buyAmount, timestamp)
    return ()

template Investor
 with
  assetManager: Party
  investor: Party
 where
  signatory assetManager
  observer investor

  key (assetManager, investor): (Party, Party)
  maintainer key._1
  
  nonconsuming choice RequestCash: ContractId CashRequest
   with amount: Decimal; currency: Text
   controller investor
   do create CashRequest with assetManager; investor; amount; currency

  nonconsuming choice Subscribe: (ContractId Fund, ContractId Token)
   with fundId: Text; subscribeAmount: Int; timestamp: Int
   controller investor
   do
    fundCid <- lookupByKey @Fund (assetManager, fundId)
    assertMsg "Fund not found" (isSome fundCid)
    fund <- fetch (fromSome fundCid)
    assertMsg "Not enough tokens available" (subscribeAmount <= fund.fundDetails.tokens)
    assertMsg "Fund is closed" (fund.fundDetails.status == OPEN)
    cashCid <- lookupByKey @Cash (assetManager, createUniqueIdentifier [(show investor), fund.fundDetails.currency])
    assertMsg "No Cash found with which to subscribe" (isSome cashCid)
    cash <- fetch (fromSome cashCid)
    assertMsg "Not enough Cash available" (cash.amount >= intToDecimal (fund.fundDetails.subscriptionCost * subscribeAmount))
    archive (fromSome cashCid)
    archive (fromSome fundCid)
    create cash with amount = cash.amount - intToDecimal(fund.fundDetails.subscriptionCost * subscribeAmount); latestUpdateTimestamp = timestamp
    fund <- create fund with fundDetails = fund.fundDetails with tokens = fund.fundDetails.tokens - subscribeAmount; latestUpdateTimestamp = timestamp
    let tokenId = createUniqueIdentifier [(show investor), fundId]
    tokenCid <- lookupByKey @Token (assetManager, tokenId)
    token <- case tokenCid of
     None -> create Token with assetManager; investor; fundId; id = tokenId; tokens = subscribeAmount; latestUpdateTimestamp = timestamp
     Some tokenCid -> do
      token <- fetch tokenCid
      archive tokenCid
      create token with tokens = token.tokens + subscribeAmount; latestUpdateTimestamp = timestamp
    return (fund, token)

  nonconsuming choice CreateBuyOffer: ContractId BuyOffer
   with fundId: Text; buyAmount: Int; currency: Text; pricePerToken: Decimal; timestamp: Int
   controller investor
   do
    fundCid <- lookupByKey @Fund (assetManager, fundId)
    assertMsg "Fund not found" (isSome fundCid)

    cashCid <- lookupByKey @Cash (assetManager, createUniqueIdentifier [(show investor), currency])
    assertMsg "Cash not found" (isSome cashCid)
    cash <- fetch (fromSome cashCid)
    assertMsg "Not enough Cash" (cash.amount >= (intToDecimal buyAmount) * pricePerToken)
    create BuyOffer with assetManager; buyer = investor; fundId; buyAmount; pricePerToken; currency; latestUpdateTimestamp = timestamp

  nonconsuming choice CreateSellOffer: ContractId SellOffer
   with fundId: Text; sellAmount: Int; currency: Text; pricePerToken: Decimal; timestamp: Int
   controller investor
   do
    fundCid <- lookupByKey @Fund (assetManager, fundId)
    assertMsg "Fund not found" (isSome fundCid)

    tokenCid <- lookupByKey @Token (assetManager, createUniqueIdentifier [(show investor), fundId])
    assertMsg "Tokens not found" (isSome tokenCid)
    token <- fetch (fromSome tokenCid)
    assertMsg "Not enough Tokens" (token.tokens >= sellAmount)
    create SellOffer with assetManager; seller = investor; fundId; sellAmount; currency; pricePerToken; latestUpdateTimestamp = timestamp